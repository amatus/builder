#!/bin/sh
set -e

## true
# avoid the shell overhead of fork/exec'ing just to call /bin/true
# returns true
true() { : ; }

## false
# avoid the shell overhead of fork/exec'ing just to call /bin/false
# returns false
false() { ! : ; }

## error <message>
# displays the supplied <message> on stderr
error() { echo "error: $*" >&2; }

## die <message>
# display the supplied <message> and exit with an error
die() { error "$*"; exit 1; }

## mkenv
# prepare the environment structure for the current package
mkenv()
{
	for dir in "${W}" "${L}" "${E}" "${D}" "${T}"; do
		if [ ! -d "${dir}" ]; then
			mkdir -p "${dir}"
		fi
	done
	unset dir

	if [ "$#" -gt "0" ]; then
		cat /dev/null > "${L}/${1}.log"
		set > "${E}/${1}.env"
	fi
}

## cleanup
# deal with temporary junk when we exit
# FIXME we need a way to universally deal w/ cleanup of junk created by
# imported commands.
cleanup()
{
	test -f "${BUILDER_MAKEFILE}" && rm -f "${BUILDER_MAKEFILE}"
	test -p "${BUILDER_PIPE}" && rm -f "${BUILDER_PIPE}"
}

## load_rules <package>
# load the Buildrules of a package into the current program space
load_rules()
{
	# Evaluate our environment data
	# There is a bit of a performance penalty here in that the query
	# routine will source the build-rules to finish collecting data, so we
	# end up sourcing the Buildrules twice.
	eval $(build-query --environ "${1}")
	RELEASE=
	S=

	# Source in the category Buildrules
	if [ -f "${BUILDER_PKGDIR}/${CATEGORY}/.buildrules" ]; then
		. "${BUILDER_PKGDIR}/${CATEGORY}/.buildrules"
	fi

	# Source in the package Buildrules
	. "${RULESFILE}"

	if [ "${CATEGORY}/${NAME}" != "${1}" ]; then
		die "Buildrules can not set the package name"
	fi

	if [ -z "${VERSION}" ]; then
		die "missing version in '${NAME}'"
	fi

	if [ -z "${DESCRIPTION}" ]; then
		die "missing description in '${NAME}'"
	fi

	if test -z "${RELEASE}"; then
		RELEASE="${VERSION#*-}"
		if ! test -z "${RELEASE}" && test "${RELEASE}" != "${VERSION}"; then
			VERSION="${VERSION%-${RELEASE}}"
			if test -z "${S}"; then
				S="${W}/${NAME}-${VERSION}-${RELEASE}"
			fi
		else
			RELEASE='0'
		fi
	fi
	if test -z "${S}"; then
		S="${W}/${NAME}-${VERSION}"
	fi
}

if [ ! -z "${BUILDER_DEBUG}" ]; then
	set -x
fi

##
# Check to see if we are wrapping a sub-command
# FIXME support custom commands
BUILDER_COMMAND=
if [ -f "${1}" ]; then
	case "${1}" in
	(*build-*)
		BUILDER_COMMAND="${1}"
		shift
		. "${BUILDER_COMMAND}"
		# exit with the exit status of the last command from within the
		# sub-script.  This is normal shell behavior, we are just
		# making it explicit.
		exit $?
		;;
	esac
fi

##
# We are being called as 'build [options] <command>'.  Setup the environment
# for execution of a sub-command.

BUILDER_DEBUG=0
while [ "$#" -gt "0" ]; do
	case "$1" in
	(-v|-version|--version)	version; exit 0;;
	(-d|-debug|--debug)
		BUILDER_DEBUG=1
		set -x
		;;
	(-h|-help|--help)
		shift 1
		set -- help "$@"
		break
		;;
	(-*)	echo "error: unknown option '${1}'" >&2
		echo "try '${0} help'" >&2
		exit 1
		;;
	(*)	break
		;;
	esac
	shift 1
done
export BUILDER_DEBUG

##
# Done with arguments, time for setting up the enviroment for the build
TOPDIR="${PWD}"
while [ ! -z "${TOPDIR}" ]; do
	[ -d "${TOPDIR}/.builder" ] && break
	TOPDIR="${TOPDIR%/*}"
done
if [ -z "${TOPDIR}" ]; then
	echo "error: current path not in a build-tree" >&2
	exit 1
fi

# set the builtin defaults based on TOPDIR.  We export TOPDIR as BUILDER_TOPDIR
# to avoid stepping on the potential usage of TOPDIR within package Makefiles
BUILDER_TOPDIR="${TOPDIR}"
BUILDER_CFGDIR="${TOPDIR}/.builder"
BUILDER_PKGDIR="${TOPDIR}/packages"
BUILDER_SRCDIR="${TOPDIR}/sources"
BUILDER_ATFDIR="${TOPDIR}/artifacts"
BUILDER_LIBDIR="${TOPDIR}/scripts/libexec"
BUILDER_TMPDIR="${TOPDIR}/tmp"

export BUILDER_CFGDIR BUILDER_PKGDIR BUILDER_SRCDIR
export BUILDER_ATFDIR BUILDER_LIBDIR BUILDER_TOPDIR
export BUILDER_TMPDIR

# We save the pre-config PATH as BUILDER_PATH to be used by downstream tools.
# FIXME detect prefixing BUILDER_LIBDIR onto PATH multiple times?
BUILDER_PATH="${BUILDER_LIBDIR}:${PATH}"
PATH="${BUILDER_PATH}"
export BUILDER_PATH PATH

# FIXME The original idea here is to allow a "default" environment, that has a "default"
# override... Basically we set some default variables, and then load the
# default config, and THEN let the target config override anything set. This
# is really confusing, and totally obsolted by an 'include' option in the configs.
test -f "${BUILDER_CFGDIR}/config" && . "${BUILDER_CFGDIR}/config"
BUILDER_CONFIG="${BUILDER_CONFIG:-config}"
if [ "${BUILDER_CONFIG}" != 'config' ]; then
	if [ ! -f "${BUILDER_CFGDIR}/${BUILDER_CONFIG}" ]; then
		die "invalid config '${BUILDER_CONFIG}'"
	fi
	. "${BUILDER_CFGDIR}/${BUILDER_CONFIG}"
fi
export BUILDER_CONFIG

# FIXME MAKE_OPTS should default to #CPUS + 1, until we can detect #CPUS, we
# just set it to 2 for uni-processor systems.
MAKE_OPTS="${MAKE_OPTS:--j2}"
export MAKE_OPTS

# Available to be set in the config
PROJECT="${PROJECT:-platform}"
ARCHIVE_FORMAT="${ARCHIVE_FORMAT:-tar.bz2}"
export PROJECT ARCHIVE_FORMAT

# If unspecified go ahead and ask gcc
CBUILD="${CBUILD:-$(build-dumpmachine)}"
export CBUILD

ARCHIVE_FORMAT="${ARCHIVE_FORMAT:-tar.bz2}"
export  ARCHIVE_FORMAT

# FIXME this stuff needs to be detected in a more reliable fashion
ARCH="${ARCH:-$(uname -m)}"
export ARCH

CHOST="${CHOST:-${CBUILD}}"
export CHOST

# if we aren't given an action then we do everything
ACTION="install"
if [ "$#" -gt "0" ]; then
	ACTION="${1}"
	shift 1
fi

# FIXME Support custom commands somehow..
if [ ! -x "${BUILDER_LIBDIR}/build-${ACTION}" ]; then
	error "unknown action '${ACTION}'"
	echo "try '${0} help'" >&2
	exit 1
fi

# query is a special case
# FIXME this is semi-busted
case "${ACTION}" in
	(query) exec "${BUILDER_LIBDIR}/build-query" "${@}";;
	(help) exec "${BUILDER_LIBDIR}/build-help" "${@}";;
esac

# If no target is given, then base our target on the current working directory,
# falling back to "${PROJECT}/all" as our default.
if [ "$#" -lt "1" ]; then
	# Are we somewhere within the pkg structure.  If this test succeeds
	# then we are at least in a category directory within the pkgdir.  Just
	# being in pkgdir is not enough to change our default argument list
	# handling.
	NAME="all"
	if [ "${PWD##${BUILDER_PKGDIR}/}" != "${PWD}" ]; then
		category="${PWD##${BUILDER_PKGDIR}/}"
		if [ "${category%%/*}" != "${category}" ]; then
			name="${category#*/}"
			category="${category%%/*}"
			NAME="${category}/${name%%/*}"
		else
			NAME="${category}/all"
		fi
		unset category
		unset name
	fi
	set -- "${NAME}"
fi

for package in "$@"; do
	# If all is specified anywhere in the argument list than just discard
	# everything else.
	if [ "${package}" = "all" ]; then
		continue
	fi
	CATEGORY="${package%%/*}"
	if [ ! -d "${BUILDER_PKGDIR}/${CATEGORY}" ]; then
		die "invalid package category '${CATEGORY}'"
	fi
	if [ "${package##*/}" != "all" ]; then
		if ! build-query --exists "${package}"; then
			exit 1
		fi
	fi
done
# sort/uniq the argument list
set -- $(for package in "$@"; do echo "${package}" ; done | sort | uniq)

# build the Makefile
trap cleanup EXIT
BUILDER_MAKEFILE="$(mktemp ${BUILDER_TMPDIR}/builder_makefile.XXXXXXXX)"
if [ ! -f "${BUILDER_MAKEFILE}" ]; then
	die "failed to generate build dependencies"
fi
export BUILDER_MAKEFILE
"${BUILDER_LIBDIR}/build-makedeps" || die "failed generate build dependencies"

packages=
for package in "$@"; do
	if [ "${package##*/}" != "all" ]; then
		package="$(build-query --pkgname "${package}")"
	fi
	package="$(echo "${package}"|tr '/-' '__')"
	packages="${packages} ${package}_${ACTION}"
done
set -- ${packages}
unset packages

# The 'tee' command will discard the exit status from 'make', so we have to
# jump through a few hoops to capture the exit status in a portable fashion.
BUILDER_PIPE="`mktemp "${BUILDER_TMPDIR}/builder_pipe.XXXXXXXX"`"
test -f "${BUILDER_PIPE}" || die 'failed to generate log-pipe placeholder'
rm -f "${BUILDER_PIPE}" && mkfifo "${BUILDER_PIPE}" || die 'failed to create log-pipe'
tee "${BUILDER_TMPDIR}/builder.log" < "${BUILDER_PIPE}" &
BUILDER_LOGGER="$!"
make -r -f "${BUILDER_MAKEFILE}" "${@}" > "${BUILDER_PIPE}" 2>&1
exit $?
