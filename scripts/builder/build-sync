#!/usr/bin/env build

echo "syncing: ${1}"
import "${1}"

build_sync_git()
{
	GIT_URI="${1%%\?*}"
	GIT_TAG="${1##*\?}"

	# We want to avoid avoid copying the repository and all of it's history
	# in order to perform a single build, unfortunately git does not give a
	# clear-cut approach to checkout out a specific tag or the head of a
	# specific branch, instead we have to jump through some hoops.
	if [ ! -d "${S}/.git" ]; then
		[ -d "${S}" ] && rm -rf "${S}"
		git clone --depth 1 "${GIT_URI}" "${S}" || die "failed to clone git source at '${GIT_URI}'"
	fi
	if [ "${GIT_TAG}" != "${GIT_URI}" ]; then
		cd "${S}" || die "failed to change working directory to '${S}'"
		git fetch --depth 1 "${GIT_URI}" "${GIT_TAG}" || die "failed to fetch git branch/tag '${GIT_TAG}'"
		git checkout "${GIT_TAG}" || die "failed to checkout git branch/tag '${GIT_TAG}'"
	fi
}

build_sync_svn()
{
	if [ ! -d "${S}/.svn" ]; then
		[ -d "${S}" ] && rm -rf "${S}"
		svn checkout "${1}" "${S}" || die "failed to checkout svn source at '${1}'"
	fi
}

build_sync_http()
{
	HTTP_FILE="${1##*/}"
	HTTP_FILE="${HTTP_FILE%%\?*}"

	if [ ! -d "${BUILDER_SRCDIR}" ]; then
		mkdir -p "${BUILDER_SRCDIR}"
	fi
	if [ ! -f "${BUILDER_SRCDIR}/${HTTP_FILE}" ]; then
		HTTP_TMP="$(mktemp /tmp/builder_${NAME}.XXXXXX)"
		if command -v "wget" > /dev/null 2>&1; then
			wget -O "${HTTP_TMP}" "${1}" || return 1
		fi

		mv "${HTTP_TMP}" "${BUILDER_SRCDIR}/${HTTP_FILE}" || return 1
	fi

	case "${HTTP_FILE}" in
	(*.tar.bz|*.tbz|*.tar.bz2|*.tbz2)
		bzip2 -dc "${BUILDER_SRCDIR}/${HTTP_FILE}" | tar x -C "${S}";;
	(*.tar.[Zz]|*.tz)
		gzip -dc "${BUILDER_SRCDIR}/${HTTP_FILE}" | tar x -C "${S}";;
	(*.tar.gz|*.tgz)
		gzip -dc "${BUILDER_SRCDIR}/${HTTP_FILE}" | tar x -C "${S}";;
	(*)	die "do not know how to extract '${HTTP_FILE}'";;
	esac

	if [ -d "${S}/${NAME}-${VERSION}" ]; then
		(cd "${S}" && find "${NAME}-${VERSION}" -maxdepth 1 \
			! -name "${NAME}-${VERSION}" -a -print0 \
			| xargs -0i mv -f "${S}/{}" "${S}/")
		rmdir "${S}/${NAME}-${VERSION}"
	fi
}

if [ ! -d "${L}" ]; then
	mkdir -p "${L}"
fi

if [ -f "${L}/sync.log" ]; then
	rm "${L}/sync.log"
fi
touch "${L}/sync.log"

for dir in "${D}" "${S}"; do
	if [ -d "${dir}" ]; then
		echo "${NAME}: prepping '${dir}' for sync" >> "${L}/sync.log"
		mv "${dir}" "${dir}.old"
		rm -rf "${dir}.old" &
	fi
	mkdir -p "${dir}"
done

wait

if [ -d "${BUILDER_PKGDIR}/${NAME}/source" ]; then
	if [ "$(command -v rsync)" ]; then
		if ! rsync -rav --delete "${BUILDER_PKGDIR}/${NAME}/source/" "${S}"; then
			die "failed to sync source to '${S}'"
		fi
	else
		if ! cp -vadpR "${BUILDER_PKGDIR}/${NAME}/source" "${S}"; then
			die "failed to copy source to '${S}'"
		fi
	fi >> "${L}/sync.log" 2>&1
else
	# FIXME this stuff needs a lot of work
	for url in ${SOURCE_URI}; do
		case "${url}" in
		(svn://*)	build_sync_svn "${url}";;
		(git://*)	build_sync_git "${url}";;
		(http://*)	build_sync_http "${url}";;
		(ftp://*)	build_sync_http "${url}";;
		# Everything else is death
		(*)		die "do not know how to handle '${url}'"
		esac >> "${L}/sync.log" 2>&1
	done
fi

# FIXME wrap up the patch command with something more functional
if [ ! -z "${PATCHES}" ]; then
	for patch in ${PATCHES}; do
		echo "${NAME}: applying patch '${patch}'" | tee -a "${L}/sync.log"
		if ! patch -l -t -d "${S}" -p1 < "${F}/${NAME}-${VERSION}-${patch}.patch"; then
			exit 1
		fi >> "${L}/sync.log" 2>&1
	done
fi

date --utc > "${L}/.synced"

# vim: filetype=sh
