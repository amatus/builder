#!/usr/bin/env build
cat >"${BUILDER_MAKEFILE}" <<EOF
##
# Some generic catchall rules
all: packages_archive
all_sync: packages_sync
all_clean: packages_clean sysroot_clean
all_distclean: packages_distclean sysroot_clean artifacts_clean tooldir_clean
all_compile: packages_compile
all_archive: packages_archive
all_install: packages_install
all_makedeps:

sysroot_clean:
	@if [ -d "${SYSROOT}" ]; then echo cleaning: sysroot;rm -rf "${SYSROOT}";fi
tooldir_clean:
	@if [ -d "${TOOLDIR}" ]; then echo cleaning: tooldir;rm -rf "${TOOLDIR}";fi
artifacts_clean:
	@if [ -d "${BUILDER_ATFDIR}" ]; then echo cleaning: artifacts;rm -rf "${BUILDER_ATFDIR}";fi


EOF

PACKAGES=
PACKAGES_SYNC=
PACKAGES_CLEAN=
PACKAGES_COMPILE=
PACKAGES_ARCHIVE=
PACKAGES_INSTALL=
PACKAGES_DISTCLEAN=
for package in $(cd "${BUILDER_PKGDIR}" && echo */*); do
	if ! eval $(build query --environ "${package}"); then
		die "in package '${package}'"
	fi

	package_make="$(echo "${package}"|tr '/-' '__')"
	package_archive="${BUILDER_ATFDIR}/${NAME}-${VERSION}.${ARCHIVE_FORMAT}"
	package_rulesfile="${RULESFILE}"
	package_logdir="${L}"
	package_install="${W}/.installed"
	package_compile="${W}/.compiled"
	package_sync="${W}/.synced"
	# FIXME we need to deal with package_source as well

	# This loop can end up being fairly costly if we have to fire up
	# build-query, particularly when dealing with a large number of
	# packages.  So we do some FS level checks first in hopes of avoiding
	# it and improving performance.
	package_deps=
	for pkg_dep in ${BDEPENDS}; do
		if [ ! -d "${BUILDER_PKGDIR}/${pkg_dep}" ]; then
			if [ ! -d "${BUILDER_PKGDIR}/${PROJECT_NAME}/${pkg_dep}" ]; then
				if ! build query --exists "${pkg_dep}"; then
					die "bad BDEPENDS in package '${package}'"
				fi
			elif [ ! -f "${BUILDER_PKGDIR}/${PROJECT_NAME}/${pkg_dep}/Buildrules" ]; then
				die "no Buildrules for '${pkg_dep}'"
			fi
			pkg_dep="${PROJECT_NAME}/${pkg_dep}"
		elif [ ! -f "${BUILDER_PKGDIR}/${pkg_dep}/Buildrules" ]; then
			die "no Buildrules for '${pkg_dep}'"
		fi
		package_deps="${package_deps} ${BUILDER_PKGDIR}/${pkg_dep}/build/.installed"
	done

cat <<EOF
##
# ${CATEGORY}/${NAME} - ${DESCRIPTION}
${package_make}: ${package_archive}
${package_make}_install: ${package_install}
${package_make}_archive: ${package_archive}
${package_make}_compile: ${package_compile}
${package_make}_sync: ${package_sync}
${package_make}_makedeps:
${package_make}_clean:
	@build-clean ${CATEGORY}/${NAME}
${package_make}_distclean:
	@build-distclean ${CATEGORY}/${NAME}
${package_install}: ${package_archive}
	@build-install ${CATEGORY}/${NAME}
${package_archive}: ${package_compile}
	@if ! build-archive ${CATEGORY}/${NAME}; then \
		echo "error: failed to archive package '${CATEGORY}/${NAME}'" >&2 ;\
		echo "logfile: '${L}/archive.log'" >&2 ;\
		exit 1; \
	fi
${package_compile}: ${package_sync}${package_deps}
	@if ! build-compile ${CATEGORY}/${NAME}; then \
		echo "error: failed to compile package '${CATEGORY}/${NAME}'" >&2 ;\
		echo "logfile: '${L}/compile.log'" >&2 ;\
		exit 1 ;\
	fi
${package_sync}: ${package_rule}
	@if ! build-sync ${CATEGORY}/${NAME}; then \
		echo "error: failed to syncronize package '${CATEGORY}/${NAME}'" >&2 ;\
		echo "logfile: '${L}/sync.log'" >&2 ;\
		exit 1 ;\
	fi

EOF

	if [ "${CATEGORY}" = "${PROJECT_NAME}" ]; then
		PACKAGES="${PACKAGES} ${package_make}"
		PACKAGES_SYNC="${PACKAGES_SYNC} ${package_sync}"
		PACKAGES_COMPILE="${PACKAGES_COMPILE} ${package_compile}"
		PACKAGES_ARCHIVE="${PACKAGES_ARCHIVE} ${package_archive}"
		PACKAGES_INSTALL="${PACKAGES_INSTALL} ${package_install}"
	fi

	PACKAGES_DISTCLEAN="${PACKAGES_DISTCLEAN} ${package_make}_distclean"
	PACKAGES_CLEAN="${PACKAGES_CLEAN} ${package_make}_clean"
done >> "${BUILDER_MAKEFILE}"

cat<<EOF >> "${BUILDER_MAKEFILE}"
packages_sync: ${PACKAGES_SYNC}
packages_clean: ${PACKAGES_CLEAN}
packages_compile: ${PACKAGES_COMPILE}
packages_archive: ${PACKAGES_ARCHIVE}
packages_install: ${PACKAGES_INSTALL}
packages_distclean: ${PACKAGES_DISTCLEAN}
EOF

# vim: filetype=sh
